#!/usr/bin/php
<?
namespace core;

include_once 'config/config.php';

//--------------------------------------------------
//          INITIALIZE
//--------------------------------------------------
function initialize()
{
    DB::query(file_get_contents("resource/schemas/init.sql"));
}

//--------------------------------------------------
//          GENERATE MODELS
//--------------------------------------------------
function generate_models()
{
    $qry= DB::query("show tables");
    $classes= array();
    
    while($table= mysql_fetch_array($qry))
    {    
        $table= $table[0];
                
        // check for habtm:
        $split= split(TABLE_SEPARATOR, $table);
        $habtm = true;
        
        if (count($split) < 2)
            $habtm= false; // no habtm
        else
        {   
            // we may have a habtm; check to make sure that the joined tables match:
            //foreach($split as $s=>$search_for_tablename)
            //{
            //    if (array_search($split[0], $search_for_tablename) === false)
            //        $habtm = false;
            //}
            
            //if ($habtm)
            //{
                // link them all together:
                foreach($split as $s=>$search_for_tablename)
                {
                    foreach($split as $s2=>$search_for_tablename2)
                    {
                        if ($search_for_tablename != $search_for_tablename2)
                            $classes[$search_for_tablename]['habtm'][]= $search_for_tablename2;
                    }
                }
            //}
        }
            
        if ($habtm == false)
        {
            $qry2= DB::query("show columns from ".$table);
            
            while($column= mysql_fetch_array($qry2))
            {
                $column= $column["Field"];
                
                if (preg_match('/_'.PRIMARY_KEY.'/', $column))
                {
                    $foreign_table= str_replace("_id","",$column);
                    print_r($foreign_table);
                    $classes[$table]['belongs_to'][]= $foreign_table;
                    $classes[$foreign_table]['has_many'][]= $table;
                }
            } // end foreach show columns
        } // end if !habtm
    } // end foreach table
    
    foreach($classes as $class=>$relations)
    {
        $file = "model/".$class.".php";
        if (file_exists($file) == false)
        {
            $f= fopen($file, "w+");
            fwrite($f,"<?\n");
            fwrite($f,"class $class extends core\\Model\n");
            fwrite($f,"{\n");
            foreach ($relations as $k=>$r)
                fwrite($f,"    protected \$$k= array('".implode("', '", $r)."');\n");
            fwrite($f,"    static function classname()\n");
            fwrite($f,"    {\n");
            fwrite($f,"        return __CLASS__;\n");
            fwrite($f,"    }\n");
            fwrite($f,"}\n");
            fwrite($f,"?>");
            fclose($f);
        }
    }
    
} // end generate models

//--------------------------------------------------
//          HSS
//--------------------------------------------------
function hss()
{
    exec("./resource/bin/hss public/css/ploof.hss");
}

//--------------------------------------------------
//          UPDATE
//--------------------------------------------------
function generate_patch($version= "trunk")
{
    if (opendir("resource/updates"))
        exec("rm -rf resource/updates");
    
    // export a copy of the code off the server:
    exec("mkdir resource/updates");
    if ($version != "trunk")
        $version= "branches/".$version;
    
    exec("svn export http://ploof.googlecode.com/svn/$version ./resource/updates/svn");
    
    // build patch files:
    exec("diff -rupN -x .svn ./core ./resource/updates/svn/core > ./resource/updates/core.patch");
    exec("diff -rupN -x .svn ./config/config.default.php ./resource/updates/svn/config/config.default.php > ./resource/updates/config.patch");
    exec("diff -rupN -x .svn ./ploof ./resource/updates/svn/ploof > ./resource/updates/ploof.patch");
    exec("diff -rupN -x .svn ./public/index.php ./resource/updates/svn/public/index.php > ./resource/updates/index.patch");
}

function patch()
{
    // apply the patches:
    exec("patch -p1 < ./resource/updates/core.patch");
    exec("patch -p1 < ./resource/updates/config.patch");
    exec("patch -p1 < ./resource/updates/ploof.patch");
    exec("patch -p1 < ./resource/updates/index.patch");
}

function update($version= "trunk")
{
    generate_patch($version);
    patch();
}
//--------------------------------------------------
//          MIGRATIONS
//--------------------------------------------------
function get_migration_path($branch)
{
    return "./resource/migrations/$branch";
}

function get_last_file_number_for($path)
{
    // input should be in the format:
    //  [number]__[text]
    $split= split("__",array_pop(scandir($path, 1))); // scan dir (reverse order) then pop and split
    return $split[0];
}

function migration($branch= "trunk")
{
    $dir= opendir(get_migration_path($branch));
    if (!$dir) 
    {
        mkdir($path);
        DB::query("insert into Versioning values(null, 0, '$branch');");
        touch($path."/1__Migration");
    }
    else
    {
        $last_number= get_last_file_number_for($path);
        touch($path."/".($last_number+1)."__Migration");
    }
}

function migrate($branch= "trunk")
{    
    $v= Versioning::find_object("branch= '".$branch."'");
    $last_db_number= $v->migration;
    $last_file_number= get_last_file_number_for(get_migration_path($branch));
    if ($last_db_number < $last_file_number)
    {
        // load them up and apply them!
        
    }
}

//--------------------------------------------------
//          CLEAN
//--------------------------------------------------
function clean()
{
    exec("rm -rf resource/updates");
}

if ($argc < 2)
{
    print "usage: ploof [command]\n\n";
    print "Commands: \n";
    print "hss..................... recreate css from hss file\n";
    print "migrate................. migrate your database to the current migration\n";
    print "migration............... create a new migration in resource/migrations\n";
    print "generate_models......... generate classfiles from your database\n";
    print "initialize.............. initialize your database\n";
    print "update.................. update via diff; you can optionally supply a version to update to (trunk is default)\n";
    print "clean................... clean various detritus that can build up\n";
    print "migration............... create a migration; optionally add the branch for this migration\n";
    print "migrate................. bring this version of the database up to date; optionally add a branch to migrate from\n";
    
    exit;
}

print "Running ".$argv[1]."... \n";

($argc < 3) ? eval("core\\".$argv[1]."();") : eval("core\\".$argv[1]."('".$argv[2]."');");

?>